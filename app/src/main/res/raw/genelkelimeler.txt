COS22
6Algori
thmsandDat
aStruc
turesFall
2011Fina
lSolutions
COS226
Algor
ithmsand
DataStru
cturesFal
l2011Final
Solutions
1. 
Analysis 
of 
algorithms. 
1 
N5=3

(a) 
T 
(N)= 
10 
. 
When 
N 
increases 
by 
a 
factor 
of 
8, 
the 
memory 
usage 
increases 
by 
a 
factor 
of 
32. 
Thus, 


T 
(N)= 
aNb, 
where 
b 
= 
log8 
32 
= 
lg32/ 
lg8 
= 
5=3. 
Since 
T 
(1000) 
= 
10000, 
we 
have 
1

10000 
= 
a 
? 
10005=3, 
which 
implies 
a 
= 


10 
. 
Remark: 
this 
is 
essentially 
the 
same 
question 
from 
the 
midterm. 


(b) 
BDFCBEA 
i. 
Single 
loop. 
ii. 
Similar 
to 
insertion 
sort. 
iii. 
Similar 
to 
enumerating 
all 
permutations. 
iv. 
Similar 
to 
mergesort 
since 
f1(N) 
takes 
linear 
time. 
v. 
N 
+ 
N=2+ 
N=4+ 
::. 
vi. 
Similar 
to 
enumerating 
all 
subsets. 
vii. 
Similar 
to 
binary 
search. 
2. 
Graph 
search. 
(a) 
280716354 
(b) 
201867435 
3. 
Minimum 
spanning 
trees. 
(a) 
1 
2 
3 
4 
5 
8 
11 
15 
(b) 
1 
5 
2 
4 
8 
3 
11 
15 
The 
starting 
vertex 
must 
be 
either 
A 
or 
F 
(but 
it 
doesn't 
matter 
which). 


1 



4. 
Shortest 
paths. 
(a) 
3 
0 
105 
2 


It 
is 
not 
necessary 
to 
run 
the 
algorithm 
from 
the 
beginning 
to 
deduce 
this 
because 
Dijkstra'
s 
algorithm 
considers 
the 
vertices 
in 
increasing 
order 
of 
distance 
from 
the 
source. 


(b) 
The 
next 
vertex 
to 
relax 
is 
4. 
v 


distTo[] 
edgeTo[] 


0 
1.0 
1 
17.0 
2 
6.0 
3 
0.0 
4 
7.0 
5 
5.0 
6 
11.0 
7 
10.0 
8 
8.0 
9 
22.0 
10 
3.0 


5. 
String 
sorting. 
c 
count[] 
count[] 
count[] 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
'a' 
0 
0 
0 
'b' 
0 
0 
3 
'c' 
3 
3 
5 
'd' 
2 
5 
11 
'e' 
6 
11 
17 
'f' 
6 
17 
20 
'g' 
3 
20 
20 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 


6. 
Substring 
search. 
The 
answer 
is 
unique. 


3 
? 
0 
5 
? 
1 
5 
? 
2 


null 


0 
? 
4 
10 
? 
5 


4 
? 
6 
4 
? 
7 
4 
? 
8 
4 
? 
9 


3 
? 
10 


i 


a[i] 
0 


blurb 
1 


climb 
2 


crumb 
3 


basic 
4 


cubic 
5 


freed 


. 


. 


. 


. 


. 


. 


18 


dwarf 
19 


cliff 


0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
A 
0 
0 
3 
0 
0 
3 
7 
0 
0 
10 
11 
B 
1 
2 
2 
4 
5 
6 
2 
8 
9 
6 
4 
s 
B 
B 
A 
B 
B 
B 
A 
B 
B 
A 
A 


2 



7. 
Regular 
expressions. 
The 
NFAs 
for 
(i), 
(ii), 
(iii), 
and 
(iv) 
would 
not 
be 
constructed 
by 
our 
RE-to-NFA 
algorithm. 
(i) 
There 
are 
two 
missing 
-transitions: 
2 
? 
6 
and 
6 
? 
2. 
(ii) 
The 
edges 
2 
? 
3 
and 
7 
? 
8 
should 
be 
match 
transitions; 
the 
edge 
3 
? 
4 
should 
be 
an 
-transition. 
(iii) 
There 
are 
two 
missing 
match 
transitions: 
2 
? 
3 
and 
4 
? 
5. 
Also, 
the 
edges 
7 
? 
8 
and 
8 
? 
9 
should 
be 
match 
transitions 
instead 
of 
-transitions. 
(iv) 
The 
-transition 
2 
? 
6 
should 
instead 
be 
0 
? 
5. 
(v) 
Correct. 
8. 
Ternary 
search 
tries. 
BD 
C 
CD 
E 
FD 
JPG 
PEGS 


9. 
String 
symbol 
table 
implementation. 
BCDE 
Find 
the 
value 
associated 
with 
a 
given 
string 
A. 
Unordered 
array. 
key 
in 
the 
data 
structure. 


CDE 
Associate 
a 
value 
with 
a 
string 
key. 
B. 
Ordered 
array. 


CDE 
Delete 
a 
string 
key 
(and 
its 
associated 
value) 


C. 
Red-black 
BST. 
from 
the 
data 
structure. 


BCE 
Find 
the 
smallest 
string 
key 
in 
the 
data 
struc-

D. 
Separate-chaining 
hash 
table. 
ture. 


BCE 
Find 
the 
smallest 
string 
key 
in 
the 
data 
struc-

E. 
Ternary 
search 
trie. 
ture 
that 
is 
greater 
than 
or 
equal 
to 
a 
given 
string. 


E 
Find 
the 
string 
key 
in 
the 
data 
structure 
that 
is 
the 
longest 
prex 
of 
a 
given 
string. 


E 
How 
many 
string 
keys 
in 
the 
data 
structure 
starts 
with 
a 
given 
prex? 


Can 
also 
be 
done 
with 
an 
ordered 
array 
(B) 
or 
a 
red-black 
BST 
(C) 
by 
calling 
rank() 
twice, 
once 
with 
the 
prex 
and 
once 
with 
the 
last 
character 
in 
the 
prex 
incremented 
by 
one. 


3 



10. 
Data 
compression. 
(a) 
CAACB 
i. 
The 
frequency 
of 
A 
can 
be 
less 
than 
the 
frequency 
of 
B 
or 
it 
can 
be 
equal 
to 
the 
frequency 
of 
B. 
ii. 
Since 
A 
and 
B 
are 
merged 
rst, 
they 
have 
are 
symbols 
that 
have 
the 
smallest 
frequencies. 
iii. 
Clearly 
freq(D) 
. 
freq(A). 
Suppose 
freq(D)= 
freq(A). 
Then, 
since 
freq(D) 
. 
freq(C) 
. 
freq(A), 
we 
must 
have 
freq(D)= 
freq(C)= 
freq(A). 
In 
this 
case, 
C 
and 
D 
would 
be 
merged 
(instead 
of 
C 
and 
fA, 
Bg). 
iv. 
If 
A, 
B, 
and 
C 
have 
frequency 
1, 
then 
D 
could 
have 
frequency 
2 
or 
3 
and 
produce 
the 
same 
subtree. 
v. 
If 
the 
frequency 
of 
E 
is 
strictly 
less 
than 
that 
of 
A, 
B, 
and 
C 
combined, 
then 
so 
is 
the 
frequency 
of 
D. 
Hence, 
D 
and 
E 
would 
be 
merged. 
Note 
that 
if 
a 
character 
appears 
0 
times, 
then 
it 
will 
not 
appear 
in 
the 
Human 
trie. 


(b) 


LZW-encoded 
message 


4241 
4E 
82 
41 
80 
42 
41 
83 
80 
41 
42 
8182 
80 
41 
42 
8183 
80 
42414E 
44 
41 
4E 
4180 


original 
message 
or 
brief 
explanation 
why 
invalid 


BANANA 
not 
possible 
since 
83 
would 
not 
yet 
be 
in 
table 
ABABBA 
ABABABA 
(see 
p. 
843 
of 
textbook) 
not 
possible 
because 
of 
second 
occurrence 
of 
41 
4E 


11. 
Maximum 

ow. 
(a) 
16+13+10 
=39. 
(b) 
s 
? 
1 
? 
2 
? 
6 
? 
5 
? 
t. 
(c) 
After 
using 
the 
previous 
augmenting 
path, 
there 
are 
no 
more 
augmenting 
paths. 
The 
value 
of 
the 
maximum 

ow 
is 
41 
(10 
+ 
15 
+ 
16). 
(d) 
fs, 
1, 
2, 
4g. 


(e) 
10+4+17+10 
=41. 
This 
equals 
the 
value 
of 
the 
maximum 

ow, 
as 
it 
should. 
Final, Fall 20111 / 64 / 410 / 109 / 110 / 152 / 515 / 1616 / 1610 / 180 / 717 / 170 / 614 / 1622 / 2210 / 10
2436s5t1
4 



12. 
Algorithm 
design. 
(a) 
Build 
an 
edge-weighted 
graph 
G. 
containing 
all 
of 
the 
edges 
whose 
weight 
is 
strictly 
less 
than 
that 
of 
e 
= 
v 
- 
w. 
Find 
the 
connected 
components 
in 
G. 
. 
By 
the 
cut 
property, 
e 
is 
in 
the 
MST 
if 
and 
only 
if 
v 
and 
w 
are 
in 
dierent 
components. 
(b) 
E 
+ 
V 
. 
13. 
Reductions. 
(a) 
For 
each 
i, 
set 
b[i] 
equal 
to 
a[i] 
and 
c[i] 
equal 
to 
-a[i]. 
b[]-66-307099-33662050c[]6630-70-9933-66-20-50
(b) 
Solution 
1: 
For 
each 
j, 
include 
the 
integer 
b[j] 
+ 
M 
(guaranteed 
to 
be 
positive); 
for 
each 
k, 
include 
the 
integer 
-(c[k] 
+ 
2*M) 
(guaranteed 
to 
be 
negative). 
Any 
triple 
in 
a[] 
that 
sums 
to 
zero 
must 
include 
two 
positive 
integers 
and 
one 
negative 
integer. 
a[] 


1299 
1700 
1010 
1014 
997 
999 
1020 
-2999 
-2019 
-1996 
-2600 
-2030 
-2020 


Solution 
2: 
For 
each 
j, 
include 
the 
integer 
10*b[j] 
+ 
1; 
for 
each 
k, 
include 
the 
integer 
-(10*c[k] 
+ 
2). 
To 
see 
why 
this 
works, 
consider 
the 
sum 
of 
the 
three 
integers 
modulo 


10. 
Note: 
can 
replace 
10 
with 
any 
integer 
greater 
than 
or 
equal 
to 
4. 
5 



